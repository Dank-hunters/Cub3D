int	parse_line_part1(char *line, t_info *map)
{
	int	ret;

	ret = 0;
	if (line[0] == '\0' && map->pass == 0)
		return (rt(0, "- File start with empty line", map));
	return (0);
}

int	parse_line(char *line, t_info *map)
--
--
			return(1);
	else if (parse_line_part3(line, map) == 1)
		return (1);
	else if (search_keys(line, map) == 1)
		return (1);
	if (map->r_f == -2 || map->r_f > 255)
		return (rt(-3, "- The R floor interval is too long", map));
--
		return (rt(-3, "- The R floor interval is too long", map));
	if (map->g_f == -2 || map->g_f > 255)
		return (rt(-3, "- The G floor interval is too long", map));
--
		return (rt(-3, "- The G floor interval is too long", map));
	if (map->b_f > 255 || map->b_f == -2)
		return (rt(-3, "- The B floor interval is too long", map));
--
		return (rt(-3, "- The B floor interval is too long", map));
	if (map->r_c == -2 || map->r_c > 255)
		return (rt(-3, "- The R floor interval is too long", map));
--
		return (rt(-3, "- The R floor interval is too long", map));
	if (map->g_c == -2 || map->g_c > 255)
		return (rt(-3, "- The G floor interval is too long", map));
--
		return (rt(-3, "- The G floor interval is too long", map));
	if (map->b_c > 255 || map->b_c == -2)
		return (rt(-3, "- The B floor interval is too long", map));
	return (0);
}

int	start_parse(char **av, t_info *map)
--
--
	char	*line;
	int		fd;
	int		ret;

	init_struct(map);
	map->start_map = 0;
	ret = 1;
--
	ret = 1;
	map->filename = av[1];
	fd = open(map->filename, O_RDONLY);
	if (fd == -1)
		return (rt(0, "- Wrong file descriptor", map));
--
	if (fd == -1)
		return (rt(0, "- Wrong file descriptor", map));
	while (ret == 1 && map->pass != 7)
	{
		ret = gnl(fd, &line);
--
	{
		ret = gnl(fd, &line);
		map->start_map++;
		if (parse_line(line, map) == 1)
		{
			free_line(line);
--
		if (parse_line(line, map) == 1)
		{
			free_line(line);
			return (rt(map->start_map, " at line : ", map));
		}
	}
	close(fd);
--
		}
	}
	close(fd);
	if (map->pass < 7 || check_info_here(map) == 1)
		return (rt(0, "there missing an info line", map));
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
--
--
	int ret;

	line = NULL;
	ret = 1;
	compt = 0;
	fd = open(map->filename, O_RDONLY);
	while (compt <=	map->start_map && ret == 1)
	{
		ret = gnl(fd, &line);
		compt++;
		if (line[0] == '\0')
--
	{
		ret = gnl(fd, &line);
		compt++;
		if (line[0] == '\0')
			map->start_map++;
		if (compt <= map->start_map)
			free_line(line);
	}
	//	dprintf(1, "%s", line);
	if (line[0] == '1' || line[0] == ' ')
		return(take_info_needed(map, fd, line));
--
--
	char *line;

	line = NULL;
	i = 0;
	ret = 1;
	map->map = malloc(sizeof(char *) * (map->line_compt + 1));
	fd = open(map->filename, O_RDONLY);
	while (map->start_map >= 0 && ret == 1)
	{
		ret = gnl(fd, &line);
--
	{
		ret = gnl(fd, &line);
		map->start_map--;
		if (map->start_map >= 0)
			free_line(line);
	}
--
			free_line(line);
	}
	map->map[i++] = ft_join(line, map);
	if (map->map[i] == NULL)
		return (rt(0, "-Erreur de malloc", map));
	free_line(line);
--
		return (rt(0, "-Erreur de malloc", map));
	free_line(line);
	while (ret == 1 && i < map->line_compt)
	{
		ret = gnl(fd, &line);
--
	{
		ret = gnl(fd, &line);
		map->map[i] = ft_join(line, map);
		free_line(line);
		i++;
	}
--
		free_line(line);
		i++;
	}
	map->map[i] = NULL;
	close(fd);
	return (0);
}

int	ft_found_pos(t_info *map)
--
--
	int y;

	i = 0;
	y = 0;
	x = 0;
	map->py = 0;
	map->px = 0;
	while (map->map[y] != 0)
	{
--
	{
		//	dprintf(1, "||%s||\n", map->map[y]);
		while(map->map[y][x])
		{
--
		{
			if (map->map[y][x] == 'N' \
					|| map->map[y][x] == 'S' \
					|| map->map[y][x] == 'E' \
					|| map->map[y][x] == 'W')
			{
				i++;
--
			{
				i++;
				map->px = x;
				map->py = y;
				map->view_d = map->map[y][x];
				dprintf(1, "le x : %i le Y : %i et les float : X : %f Y : %f", x, y, map->px, map->py);
			}
			x++;
		}
		x = 0;
		y++;
--
--
		y++;
	}
	y = 0;
	if (i == 0)
	{
		while(y < map->line_compt)
		{
--
		{
			free_line(map->map[y]);
			y++;
		}
--
			y++;
		}
		free(map->map);
		return (rt(0, "there are no player", map));
	}
	if (i >= 2)
	{
--
		return (rt(0, "there are no player", map));
	}
	if (i >= 2)
	{
		while(y < map->line_compt)
		{
--
		{
			free_line(map->map[y]);
			y++;
		}
--
			y++;
		}
		free(map->map);
		return (rt(0, "there are more than 1 spawn point", map));
	}
	return (0);
}

--
--
	return (0);
}

void error(t_info *map)
{
	map->not_close = 6;
	ft_putstr("-Error\nThe map is not close");
	exit(0);
}

void    fill_flood_map(t_info *map, int y, int x)
--
--
	exit(0);
}

void    fill_flood_map(t_info *map, int y, int x)
{
	if (y < 0 || x < 0 || y > map->line_compt - 1 || \
			x > map->line_size - 1)
		error(map);
--
		error(map);
	if (ft_ischar("|.$#", map->map[y][x]))
		return;
--
		return;
	if (map->map[y][x] == '1')
	{
--
	{
		map->map[y][x] = '|';
		return ;
	}
--
		return ;
	}
	if (map->map[y][x] == '0')
		map->map[y][x] = '.';
	if (map->map[y][x] == '2')
		map->map[y][x] = '$';
	if (map->map[y][x] == '3')
		map->map[y][x] = '#';
	fill_flood_map(map, y - 1, x);
	fill_flood_map(map, y + 1, x);
	fill_flood_map(map, y, x - 1);
	fill_flood_map(map, y, x + 1);
}
--
--
	int i;
	int y;

	y = 0;
	i = 0;
	while (i < map->line_compt)
	{
--
	{
		//	dprintf(1, "%s\n", map->map[i]);
		if (map->map[i][0] == '\0')
		{
--
		{
			while(y < map->line_compt)
			{
--
			{
				free_line(map->map[y]);
				y++;
			}
--
				y++;
			}
			free(map->map);
			return (rt(0, "-Empty line in middle or a the end of map", map));
		}
		i++;
	}
	return (0);
--
--
}

int parse_map(t_info *map)
{
	int i = 0;
	map->tofree = 0;
	if (found_start_map(map) == 1)
		return (1);
	init_tab_map(map);
	if (test_map(map) == 1)
		return (1);
--
--
	init_tab_map(map);
	if (test_map(map) == 1)
		return (1);
	if (ft_found_pos(map) == 1)
		return (1);
	fill_flood_map(map, map->py, map->px);
	if (map->not_close == 6)
	{
--
	{
		while (i < map->line_compt)
		{
--
		{
			free_line(map->map[i]);
			i++;
		}
--
			i++;
		}
		free(map->map);
		return (rt(0, "The map is not close", map));
	}
	dprintf(1, "lets go parse");
	return (0);
}
--
--

#include "../cub3d.h"

int	parse_ceiling_color(char *line, t_info *map, int	i)
{
	map->pass++;
	if (line[i] != ' ')
		return (rt(-1, "- After C. ", map));
	i = skip_space(line, i);
	if (line[i] < '0' && line[i] > '9')
		return (rt(1, "- Before R. ", map));
--
--
	if (line[i] != ' ')
		return (rt(-1, "- After C. ", map));
	i = skip_space(line, i);
	if (line[i] < '0' && line[i] > '9')
		return (rt(1, "- Before R. ", map));
	map->r_c = take_size(line, i);
	i = skip_num(line, i);
	if (line[i] != ',')
		return (rt(-1, "- Between R & G. ", map));
	i = skip_space(line, i + 1);
	if (line[i] > '9' || line[i] < '0')
--
--
	if (line[i] != ',')
		return (rt(-1, "- Between R & G. ", map));
	i = skip_space(line, i + 1);
	if (line[i] > '9' || line[i] < '0')
		return (rt(-1, "- Between R & G. ", map));
	map->g_c = take_size(line, i);
	i = skip_num(line, i);
	if (line[i] != ',')
		return (rt(-1, "- Between G & B. ", map));
	i = skip_space(line, i + 1);
	if (line[i] > '9' || line[i] < '0')
--
--
	if (line[i] != ',')
		return (rt(-1, "- Between G & B. ", map));
	i = skip_space(line, i + 1);
	if (line[i] > '9' || line[i] < '0')
		return (rt(-1, "- Between G & B. ", map));
	map->b_c = take_size(line, i);
	i = skip_num(line, i);
	if (line[i])
		return (rt(-1, "- Too few caracters after B. ", map));
	//free_line(line);
	return (0);
--
--
	return (0);
}

int	parse_floor_color(char *line, t_info *map, int	i)
{
	map->pass++;
	if (line[i] != ' ')
		return (rt(-3, "- After idd", map));
	i = skip_space(line, i);
	if (line[i] < '0' && line[i] > '9')
		return (rt(-3, "- Before G\n", map));
--
--
	if (line[i] != ' ')
		return (rt(-3, "- After idd", map));
	i = skip_space(line, i);
	if (line[i] < '0' && line[i] > '9')
		return (rt(-3, "- Before G\n", map));
	map->r_f = take_size(line, i);
	i = skip_num(line, i);
	if (line[i] != ',')
		return (rt(-3, "- Missng ','\n", map));
	i = skip_space(line, i + 1);
	if (line[i] > '9' || line[i] < '0')
--
--
	if (line[i] != ',')
		return (rt(-3, "- Missng ','\n", map));
	i = skip_space(line, i + 1);
	if (line[i] > '9' || line[i] < '0')
		return (rt(-3, "- Between R & G\n", map));
	map->g_f = take_size(line, i);
	i = skip_num(line, i);
	if (line[i] != ',')
		return (rt(-3, "- Between  G & B\n", map));
	i = skip_space(line, i + 1);
	if (line[i] > '9' || line[i] < '0')
--
--
	if (line[i] != ',')
		return (rt(-3, "- Between  G & B\n", map));
	i = skip_space(line, i + 1);
	if (line[i] > '9' || line[i] < '0')
		return (rt(-3, "- Between  G & B\n", map));
	map->b_f = take_size(line, i);
	i = skip_num(line, i);
	if (line[i])
		return (rt(-3, "- Too few characters after B\n", map));
//	free_line(line);
	return (0);
--
--

#include "../cub3d.h"

int	parse_no_texture(char *line, t_info *map, int	i)
{
	map->pass++;
	if (line[i] != ' ')
		return (rt(0, "- Before NO taces path ", map));
	i = skip_space(line, i);
--
	if (line[i] != ' ')
		return (rt(0, "- Before NO taces path ", map));
	i = skip_space(line, i);
	if (map->pt_no_t== NULL)
		map->pt_no_t= line + i;
	else 
		return (rt(0, "the NO tpath line is duplicate", map));
--
	else 
		return (rt(0, "the NO tpath line is duplicate", map));
	if (map->pt_no_t== NULL)
		return (rt(0, "-In malloc", map));
	if (found_extention(line) == 1)
		return (rt(0, "-  Wrong extension of the NO texture", map));
	return (0);
}
--
--
	return (0);
}

int	parse_so_texture(char *line, t_info *map, int	i)
{
	map->pass++;
	if (line[i] != ' ')
		return (rt(0, "- Before SO taces path ", map));
	i = skip_space(line, i);
--
	if (line[i] != ' ')
		return (rt(0, "- Before SO taces path ", map));
	i = skip_space(line, i);
	if (map->pt_so_t== NULL)
		map->pt_so_t= line + i;
	else 
		return (rt(0, "the SO tpath line is duplicate", map));
--
	else 
		return (rt(0, "the SO tpath line is duplicate", map));
	if (map->pt_so_t== NULL)
		return (rt(0, "-In malloc", map));
	if (found_extention(line) == 1)
		return (rt(0, "-  Wrong extension of the SO texture", map));
	return (0);
}
--
--
	return (0);
}

int	parse_we_texture(char *line, t_info *map, int	i)
{
	map->pass++;
	if (line[i] != ' ')
		return (rt(0, "- Before WE taces path ", map));
	i = skip_space(line, i);
--
	if (line[i] != ' ')
		return (rt(0, "- Before WE taces path ", map));
	i = skip_space(line, i);
	if (map->pt_we_t== NULL)
		map->pt_we_t= line + i;
	else 
		return (rt(0, "the WE tpath line is duplicate", map));
--
	else 
		return (rt(0, "the WE tpath line is duplicate", map));
	if (map->pt_we_t== NULL)
		return (rt(0, "-In malloc", map));
	if (found_extention(line) == 1)
		return (rt(0, "-  Wrong extension of the WE texture", map));
	return (0);
}
--
--
	return (0);
}

int	parse_ea_texture(char *line, t_info *map, int	i)
{
	map->pass++;
	if (line[i] != ' ')
		return (rt(0, "- Before EA taces path ", map));
	i = skip_space(line, i);
--
	if (line[i] != ' ')
		return (rt(0, "- Before EA taces path ", map));
	i = skip_space(line, i);
	if (map->pt_ea_t== NULL)
		map->pt_ea_t= line + i;
	else 
		return (rt(0, "the EA tpath line is duplicate", map));
--
	else 
		return (rt(0, "the EA tpath line is duplicate", map));
	if (map->pt_ea_t== NULL)
		return (rt(0, "-In malloc", map));
	if (found_extention(line) == 1)
		return (rt(0, "-  Wrong extension of the EA texture", map));
	return (0);
}
--
--
	return (0);
}

int	parse_sprite_texture(char *line, t_info *map, int	i)
{
	map->pass++;
	if (line[i] != ' ')
		return (rt(0, "- Before sp taces path ", map));
	i = skip_space(line, i);
--
	if (line[i] != ' ')
		return (rt(0, "- Before sp taces path ", map));
	i = skip_space(line, i);
	if (map->pt_sp_t== NULL)
		map->pt_sp_t= line + i;
	else 
		return (rt(0, "the sp tpath line is duplicate", map));
--
	else 
		return (rt(0, "the sp tpath line is duplicate", map));
	if (map->pt_sp_t== NULL)
		return (rt(0, "-In malloc", map));
	if (found_extention(line) == 1)
		return (rt(0, "-  Wrong extension of the sp texture", map));
	return (0);
}
--
--
	return (size);
}

void	init_struct(t_info *map)
{
	map->pass = 0;
	map->res_x = -1;
	map->res_y = -1;
	map->r_f = -1;
	map->g_f = -1;
	map->b_f = -1;
	map->r_c = -1;
	map->g_c = -1;
	map->b_c = -1;
	map->line_size = 0;
	map->line_compt = 0;
	map->pt_no_t= NULL;
	map->pt_so_t= NULL;
	map->pt_we_t= NULL;
	map->pt_ea_t= NULL;
	map->pt_sp_t= NULL;
	map->filename = NULL;
}

int	search_keys(char *line, t_info *map)
{
	if ((line[0] == 'C') \
--
--
	return (0);
}

int	check_info_here(t_info *map)
{
	if (map->res_x == -1 || map->res_y == -1 || map->r_f == -1 \
			|| map->g_f == -1 || map->b_f == -1 \
			|| map->r_c == -1 || map->g_c == -1 \
			|| map->b_c == -1)
		return (1);
--
		return (1);
	if (map->pt_no_t == NULL \
			|| map->pt_so_t == NULL \
			|| map->pt_we_t == NULL \
			|| map->pt_ea_t == NULL \
			|| map->pt_sp_t == NULL)
		return (1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
--
--
int	take_info_needed(t_info *map, int fd, char *line)
{
	int	ret;

	ret = 1;
	map->line_compt = 1;
	map->line_size = ft_strlen(line);
	map->line_compt = 0;
	while (ret == 1)
	{
		if (ft_parse_char(line) == 1)
		{
			free_line(line);
--
--
		{
			free_line(line);
			return (rt(0, "wrong caracteres in map", map));
		}
		ret = gnl(fd, &line);
		map->line_compt++;
		if (ft_strlen(line) > map->line_size)
			map->line_size = ft_strlen(line);
	}
	free_line(line);
	close(fd);
	return (0);
}
--
--
{
	int		i;
	char	*dest;

	i = 0;
	dest = malloc(sizeof(char) * (map->line_size + 1));
	while (line[i])
	{
		dest[i] = line[i];
		i++;
	}
--
--
	while (line[i])
	{
		dest[i] = line[i];
		i++;
	}
	while (ft_strlen(line) != 0 && i < map->line_size)
	{
		dest[i] = ' ';
		i++;
	}
	dest[i] = '\0';
